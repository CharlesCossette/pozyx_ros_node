#!/usr/bin/env python

import pypozyx
import rospy
from std_msgs.msg import String

# from package-name.msg import custom_msg
from pozyx_ros_node.msg import range_msg, imu_msg
from time import time

# Yea so nanoseconds are really annoying. 
# Can we change this?
time_ns = lambda: int(round(time() * 1e9))

def findPozyxSerial():
    """
    Automatically checks this computer's serial ports for any pozyx
    devices connected through USB.

    RETURNS:
    -------
        pozyxs: [list] of [pypozyx.PozyxSerial] containing one
            PozyxSerial() object per connected pozyx device.
        pozyx_ids: [list] of IDs corresponding to the above PozyxSerial() list
    """
    # Detect Pozyx device on serial ports, get serial port address.
    pozyx_devices = list()
    for port in pypozyx.get_serial_ports():
        if pypozyx.is_pozyx_port(port):
            pozyx_devices.append(port.device)

    if not pozyx_devices:
        print("No Pozyx connected. Check your USB cable or your driver!")
        quit()
    else:
        print("Pozyx device(s) detected on serial port(s): " \
              + str(pozyx_devices) + ".")

    # Initialize connection to serial port.
    pozyx_serials = list()
    pozyx_ids = list()
    #for serial_port in pozyx_devices:
    #print(serial_port)
    pozyx = pypozyx.PozyxSerial('/dev/ttyACM0')
    who_am_i = pypozyx.NetworkID()
    status = pozyx.getNetworkId(who_am_i)
    if status == pypozyx.POZYX_FAILURE:
        print("ERROR: Failed to obtain device ID.")

    pozyx_serials.append(pozyx)
    pozyx_ids.append(who_am_i.id)

    return pozyx_serials, pozyx_ids

def findNeighbors(pozyx, remote_id = None):
    """
    Automatically discovers any pozyx anchor or tag devices within UWB range.

    PARAMETERS:
    -----------
    pozyx: pypozyx.PozyxSerial object
        PozyxSerial object as generated by pypozyx.PozyxSerial(serial_port)
    remote_id: (optional) hexidecimal
        If you want to perform this function "remotely" on another pozyx 
        pozyx device, enter its ID here. Otherwise, do not pass this argument

    RETURNS:
    --------
    device_lists: pypozyx.DeviceList
        list containing the device IDs
    """

    # Get ID of current pozyx device
    who_am_i = pypozyx.NetworkID()
    pozyx.getNetworkId(who_am_i)

    # Discover other pozyx devices
    pozyx.clearDevices(remote_id=remote_id)
    pozyx.doDiscoveryAll(remote_id=remote_id)
    device_list_size = pypozyx.SingleRegister()
    pozyx.getDeviceListSize(device_list_size, remote_id=remote_id)
    device_list = pypozyx.DeviceList(list_size=device_list_size.value)
    pozyx.getDeviceIds(device_list, remote_id=remote_id)

    # Print device list
    # TODO: we will have to check these print statements with the ROS framework.
    # What is the best way to print info to screen with ROS?
    id_string = "Device " + str(hex(who_am_i.id)) + " has discovered the following other devices: " 
    for id in device_list.data:
        id_string += str(hex(id)) + ", "



    # if not allow_self_ranging:
    #     print("However, self-ranging is currently deactivated. " \
    #           + "No range measurements between devices connected to the same computer ")
    return device_list

class DataSource(object):
    """
    Abstract class. Your data source objects should inherit this class. The

        >>> self.data_ready [boolean]

    property can be used to signal to the data collector when new data is ready
    for collection.
    """

    def __init__(self):
        self.data_ready = True

    def getHeader(self):
        """
        This is a virtual function.

        This function should return the headers for each column as a list of
        headers for each column.
        """

        raise NotImplementedError(
            "You need to implement a getHeader() function in your data source.")

    def getData(self):
        """
        This is a virtual function.

        This function should return a list of data values, for each column of
        this data source.
        """

        raise NotImplementedError(
            "You need to implement a getData() function in your data source.")

class PozyxImuSource(DataSource):
    """
    Create a Pozyx IMU source object which can read and return sensor from the
    pozyx device. Certain readings can be excluded using, as an example,

        source = PozyxImuSource(pozyx, mag = False)
        source = PozyxImuSource(pozyx, mag = False, pres = False)
        source = PozyxImuSource(pozyx, gyro = False)
        source = PozyxImuSource(pozyx, remote_id = 0x6a25)

    This class does NOT record range measurements. See PozyxRangeSource()
    """

    def __init__(self, pozyx, accel=True, gyro=True, mag=True,
                 pres=True, euler=False, quat=False, remote_id=None):
        super(PozyxImuSource,self).__init__()

        # Settings
        self.record_accel = accel
        self.record_gyro = gyro
        self.record_mag = mag
        self.record_pres = pres
        self.record_euler = euler
        self.record_quat = quat
        self.remote_id = remote_id
        self.time_offset = 0
        # Internal variables
        self.pozyx = pozyx
        who_am_i = pypozyx.NetworkID()
        self.pozyx.getNetworkId(who_am_i)
        if self.remote_id is not None:
            self.id = remote_id
            print('Accessing ' + str(hex(self.id)) + ' remotely from ' \
                  + str(hex(who_am_i.id) + '.'))
        else:
            self.id = who_am_i.id
        print('Initalization complete.')

    def getHeader(self):
        """
        Generates the header for the Pozyx IMU Source.
        """
        header_fields = list()
        header_fields.append('Timestamp_ns_Clock_Offset_' + str(self.time_offset))

        # Generate the header string
        if self.record_accel:
            header_fields.append("id_" + str(hex(self.id)) + "_Accel_x_mg")
            header_fields.append("id_" + str(hex(self.id)) + "_Accel_y_mg")
            header_fields.append("id_" + str(hex(self.id)) + "_Accel_z_mg")

        if self.record_gyro:
            header_fields.append("id_" + str(hex(self.id)) + "_Gyro_x_deg_s")
            header_fields.append("id_" + str(hex(self.id)) + "_Gyro_y_deg_s")
            header_fields.append("id_" + str(hex(self.id)) + "_Gyro_z_deg_s")

        if self.record_mag:
            header_fields.append("id_" + str(hex(self.id)) + "_Mag_x_uT")
            header_fields.append("id_" + str(hex(self.id)) + "_Mag_y_uT")
            header_fields.append("id_" + str(hex(self.id)) + "_Mag_z_uT")

        if self.record_euler:
            header_fields.append("id_" + str(hex(self.id)) + "_Roll_deg")
            header_fields.append("id_" + str(hex(self.id)) + "_Pitch_deg")
            header_fields.append("id_" + str(hex(self.id)) + "_Yaw_deg")

        if self.record_quat:
            header_fields.append("id_" + str(hex(self.id)) + "_Quat_w")
            header_fields.append("id_" + str(hex(self.id)) + "_Quat_x")
            header_fields.append("id_" + str(hex(self.id)) + "_Quat_y")
            header_fields.append("id_" + str(hex(self.id)) + "_Quat_z")

        if self.record_pres:
            header_fields.append("id_" + str(hex(self.id)) + "_Pressure_Pa")
        return header_fields

    def getData(self):
        """
        Reads the Pozyx IMU/mag/barometer and returns the data as a list.
        """

        # Containers for storing the data
        data_values = list()

        # Hold until a new IMU measurement is available.
        self.pozyx.waitForFlagSafe(pypozyx.PozyxBitmasks.INT_MASK_IMU, 0.1)

        # Create datastring
        data_values.append(time_ns() - self.time_offset)
        if self.record_accel:
            accel_data = pypozyx.Acceleration()
            self.pozyx.getAcceleration_mg(accel_data, remote_id=self.remote_id)
            data_values.append(accel_data.x)
            data_values.append(accel_data.y)
            data_values.append(accel_data.z)

        if self.record_gyro:
            gyro_data = pypozyx.AngularVelocity()
            self.pozyx.getAngularVelocity_dps(gyro_data, remote_id=self.remote_id)
            data_values.append(gyro_data.x)
            data_values.append(gyro_data.y)
            data_values.append(gyro_data.z)

        if self.record_mag:
            mag_data = pypozyx.Magnetic()
            self.pozyx.getMagnetic_uT(mag_data, remote_id=self.remote_id)
            data_values.append(mag_data.x)
            data_values.append(mag_data.y)
            data_values.append(mag_data.z)

        if self.record_euler:
            euler_data = pypozyx.EulerAngles()
            self.pozyx.getEulerAngles_deg(euler_data, remote_id=self.remote_id)
            data_values.append(euler_data.roll)
            data_values.append(euler_data.pitch)
            data_values.append(euler_data.heading)

        if self.record_quat:
            quat_data = pypozyx.Quaternion()
            self.pozyx.getQuaternion(quat_data, remote_id=self.remote_id)
            data_values.append(quat_data.w)
            data_values.append(quat_data.x)
            data_values.append(quat_data.y)
            data_values.append(quat_data.z)

        if self.record_pres:
            pres_data = pypozyx.Pressure()
            self.pozyx.getPressure_Pa(pres_data, remote_id=self.remote_id)
            data_values.append(pres_data.value)

        return data_values

class PozyxRangeSource(DataSource):
    """
    Create a Pozyx Range source object to do UWB ranging with other pozyx
    devices. Will automatically detect other pozyx devices within UWB range.

    PARAMETERS:
    -----------
        pozyx: pypozyx.PozyxSerial object. 
            See findPozyxSerial()
        exclude_ids: list
            list of device network ids to exclude from the ranging process.
        allow_self_ranging: bool
            Set to true to allow range measurements to IDs in exclude_ids
            This was designed for when you have multiple pozyx devices connected
            to the same computer
    """

    def __init__(self, pozyx_serial, exclude_ids=[],
                 allow_self_ranging=True, remote_id=None):
        super(PozyxRangeSource, self).__init__()
        self.pozyx = pozyx_serial
        self.allow_self_ranging = allow_self_ranging
        self.exclude_ids = exclude_ids
        self.remote_id = remote_id
        self.time_offset = 0

        who_am_i = pypozyx.NetworkID()
        self.pozyx.getNetworkId(who_am_i)
        if self.remote_id is not None:
            self.id = remote_id
            print('Accessing ' + str(hex(self.id)) + ' remotely from ' \
                  + str(hex(who_am_i.id) + '.'))
        else:
            self.id = who_am_i.id

        self.device_list = findNeighbors(self.pozyx, self.remote_id)
        self._neighbor_to_range = 0
        self._number_of_neighbors = len(self.device_list.data)

    def getHeader(self):

        """
        Creates the header for the Pozyx Range source.
        """
        header_fields = list()
        header_fields.append('Timestamp_ns_Clock_Offset_' + str(self.time_offset))
        for id in self.device_list.data:
            header_fields.append("id_" + str(hex(self.id)) \
                                 + '_to_' + str(hex(id)) + 'Boot_Time_Pozyx_ms')
            header_fields.append("id_" + str(hex(self.id)) \
                                 + '_Range_to_' + str(hex(id)) + '_mm')
            header_fields.append("id_" + str(hex(self.id)) \
                                 + '_RSS_to_' + str(hex(id)) + '_dB')
        return header_fields

    def getData(self):
        """
        Performs ranging with one of its neighbors. A different neighbor is
        selected on each of these function calls. Returns range and RSS data.
        """
        if len(self.device_list.data) != 0:
            # Perform the ranging, exclude self-ranging if user has chosen this.
            device_range = pypozyx.DeviceRange()
            status_range = pypozyx.POZYX_FAILURE
            id = self.device_list.data[self._neighbor_to_range]
            if id in self.exclude_ids and not self.allow_self_ranging:
                pass
            else:
                status_range = self.pozyx.doRanging(id, device_range,
                                                    remote_id=self.remote_id)
                if status_range != pypozyx.POZYX_SUCCESS:
                    # Try ranging a second time, sometimes this occurs
                    # if multiple devices are used.
                    status_range = self.pozyx.doRanging(id, device_range, remote_id=self.remote_id)

            # Put data in list.
            data_values = list()
            data_values.append(time_ns() - self.time_offset)
            #data_values += [" "] * 3 * self._neighbor_to_range

            # Placeholder for empty values here. 
            # NaN's have to be Floats but we want to store these as integers. 
            empty_data_value = 0
            data_values += [empty_data_value] * 3 * self._neighbor_to_range
            if status_range == pypozyx.POZYX_SUCCESS:
                data_values.append(device_range.timestamp)
                data_values.append(device_range.distance)
                data_values.append(device_range.RSS)
            else:
                #data_values += [" "] * 3
                data_values += [empty_data_value] * 3
            #data_values += [" "] * 3 * (len(self.device_list.data) - 1 - self._neighbor_to_range)
            data_values += [empty_data_value] * 3 * (len(self.device_list.data) - 1 - self._neighbor_to_range)

            # New neighbor for next function call.
            if self._neighbor_to_range == (self._number_of_neighbors - 1):
                self._neighbor_to_range = 0
            else:
                self._neighbor_to_range += 1
        else:
            data_values = list()
            data_values.append(time_ns() - self.time_offset)
        return data_values

class PozyxPositionSource(DataSource):

    def __init__(self, pozyx, anchors):
        super().__init__()

        # positioning algorithm to use, other is PozyxConstants.POSITIONING_ALGORITHM_UWB_ONLY
        self.algorithm = pypozyx.PozyxConstants.POSITIONING_ALGORITHM_TRACKING
        # self.algorithm = pypozyx.PozyxConstants.POSITIONING_ALGORITHM_UWB_ONLY
        self.dimension = pypozyx.PozyxConstants.DIMENSION_3D
        self.time_offset = 0
        self.pozyx = pozyx
        who_am_i = pypozyx.NetworkID()
        self.pozyx.getNetworkId(who_am_i)
        self.id = who_am_i.id
        self.rangeOnceToAll()
        self.setAnchorsManual(anchors)
        print('Initalization complete.')

    def rangeOnceToAll(self):
        """
        Automatically discovers any pozyx anchor or tag devices within UWB range,
        and ranges to them. Apparently it helps to range ones to all the other
        devices before starting positions. Produces a more consistent position
        stream.

        Returns:
            device_lists: [pypozyx.DeviceList] list containing the device IDs
        """

        # Get ID of current pozyx device
        who_am_i = pypozyx.NetworkID()
        self.pozyx.getNetworkId(who_am_i)

        # Discover other pozyx devices
        self.pozyx.clearDevices()
        self.pozyx.doDiscoveryAll()
        device_list_size = pypozyx.SingleRegister()
        self.pozyx.getDeviceListSize(device_list_size)
        device_list = pypozyx.DeviceList(list_size=device_list_size.value)
        self.pozyx.getDeviceIds(device_list, )

        # Print device list
        id_string = "Device " + str(hex(self.id)) + " has discovered the following other devices: "
        for id in device_list.data:
            id_string += str(hex(id)) + ", "


        # Perform the ranging, exclude self-ranging if user has chosen this.
        device_range = pypozyx.DeviceRange()
        status_range = pypozyx.POZYX_FAILURE
        for id in device_list.data:
            status_range = self.pozyx.doRanging(id, device_range)
        if status_range != pypozyx.POZYX_SUCCESS:
            # Try ranging a second time, sometimes this occurs
            # if multiple devices are used.
            status_range = self.pozyx.doRanging(id, device_range)
        print(device_range.distance)

    def getHeader(self):
        """
        Creates the header for the pozyx position source.
        """
        header_fields = list()
        header_fields.append('Timestamp_ns_Clock_Offset_' + str(self.time_offset))
        header_fields.append("id_" + str(hex(self.id)) + "_Pos_x_mm")
        header_fields.append("id_" + str(hex(self.id)) + "_Pos_y_mm")
        header_fields.append("id_" + str(hex(self.id)) + "_Pos_z_mm")
        header_fields.append("id_" + str(hex(self.id)) + "_Pressure_Pa")
        header_fields.append("id_" + str(hex(self.id)) + "_Temperature_C")
        return header_fields

    def setAnchorsManual(self, anchors):
        """
        Adds the manually measured anchors to the Pozyx's device list
        one for one.
        """

        self.pozyx.clearDevices()
        for anchor in anchors:
            status = self.pozyx.addDevice(anchor)
        if len(anchors) > 4:
            status = self.pozyx.setSelectionOfAnchors(pypozyx.PozyxConstants.ANCHOR_SELECT_AUTO, len(anchors))

        return status

    def getData(self):
        """
        Performs the built-in positioning algorithm on the pozyx device and
        returns the data.
        """
        position = pypozyx.Coordinates()
        data_values = list()

        status = self.pozyx.doPositioning(position, self.dimension, self.algorithm)
        data_values.append(time_ns() - self.time_offset)
        
        if status is pypozyx.POZYX_SUCCESS:
            data_values.append(str(position.x))
            data_values.append(str(position.y))
            data_values.append(str(position.z))
            print(data_values)
        else:
            data_values += [''] * 3
            #print("BONG BONG WOO")
            #data_values += ["a"] * 3

        pres_data = pypozyx.Pressure()
        self.pozyx.getPressure_Pa(pres_data)
        data_values.append(pres_data.value)

        temp_data = pypozyx.Temperature()
        self.pozyx.getTemperature_c(temp_data)
        data_values.append(temp_data.value)
        
        return data_values

# Modified tutorial. http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28python%29
def pozyx_node():
    pozyxs, ids = findPozyxSerial()
    
    # TODO: This needs to go into a .yaml file 
    anchors = [pypozyx.DeviceCoordinates(0x6f4a, 1, pypozyx.Coordinates(2594, -2110, 1845)),
               pypozyx.DeviceCoordinates(0x6f58, 1, pypozyx.Coordinates(-75, 2116, 149)),
               pypozyx.DeviceCoordinates(0x6f5f, 1, pypozyx.Coordinates(4731, 2149, 2120)),
               pypozyx.DeviceCoordinates(0x6f60, 1, pypozyx.Coordinates(-4232, 460, 2400)),
               pypozyx.DeviceCoordinates(0x6f61, 1, pypozyx.Coordinates(-505, -2080, 474))]

    # Create data source objects
    # TODO: we need user toggles to collect these or not.
    # TODO: currently only supporting one single pozyx sensor. need to extend to
    # multiple. we can do this once we have it figured out for one. 
    # TODO: Position source not yet enabled.
    # TODO: allow_self_ranging to be a user option.
    imu_source = PozyxImuSource(pozyxs[0])
    range_source = PozyxRangeSource(pozyxs[0], exclude_ids=ids,
                                            allow_self_ranging=False)
    #pos_source  = PozyxPositionSource(pozyxs[0], anchors)

    # Initialize publishers
    rospy.init_node('pozyx_node', anonymous=True)
    pub_range = rospy.Publisher('pozyx_range', range_msg, queue_size=10) # Wont this result in publishing String?
    pub_imu = rospy.Publisher('pozyx_imu', imu_msg, queue_size=10)
    #pub_pos = rospy.Publisher('pozyx_position', String, queue_size=10) 

    # Get all headers
    headers_range = range_source.getHeader()
    headers_imu = imu_source.getHeader()

    #headers_pos = pos_source.getHeader()

    rate = rospy.Rate(10) # 10hz - What does Husky actually use?
                          # TODO: we need to check this.
    
    while not rospy.is_shutdown():
        data_range =  range_source.getData()
        data_imu =  imu_source.getData()
        #data_pos = pos_source.getData() 
        # Isnt this meant for sporadic info instead of a huge datastream?
        #rospy.loginfo(**dict(zip(headers, data_values))) 

        # Pass the message using kwargs i.e. pub_range.publish(message_field_1='foo', message_field_2='bar')

        # pub_range.publish(cat="1") 
        pub_range.publish(**dict(zip(headers_range, data_range))) 
        pub_imu.publish(**dict(zip(headers_imu, data_imu))) 
        

if __name__ == '__main__':
    try:
        pozyx_node()
    except rospy.ROSInterruptException:
        pass
